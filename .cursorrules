# swiftETH Development Rules

## Project Overview
swiftETH is a modern Swift library for Ethereum and Web3 functionality, inspired by the architecture and API design of oxlib.sh. This library provides cryptographically secure account management, transaction signing, and blockchain interaction for Swift applications.

## Core Philosophy

### 1. Architecture Inspiration: oxlib.sh
- Follow oxlib.sh's modular, composable design patterns
- Prioritize developer experience with intuitive APIs
- Keep the library lightweight and dependency-minimal
- Provide both low-level primitives and high-level abstractions
- Maintain feature parity where Swift patterns allow

### 2. Swift Best Practices
- Use Swift's type system for compile-time safety
- Leverage async/await for asynchronous operations
- Prefer value types (structs) over reference types where appropriate
- Use protocol-oriented programming for extensibility
- Follow Swift naming conventions (camelCase for variables/functions, PascalCase for types)
- Minimize force-unwrapping (!); prefer guard/if let or nil coalescing

### 3. Code Quality Standards
- **Zero compiler warnings** - All code must compile cleanly
- **No force-unwraps in production code** - Use safe unwrapping patterns
- **Explicit error handling** - All errors must be typed and descriptive
- **Thread safety** - All public APIs must be thread-safe
- **Memory safety** - Avoid retain cycles, use weak/unowned appropriately

## Project Structure

```
Sources/
  swiftETH/
    Account.swift          # Account management (key generation, signing)
    Address.swift          # Ethereum address with checksumming
    PrivateKey.swift       # Secure private key handling
    PublicKey.swift        # Public key derivation
    Signature.swift        # ECDSA signatures and recovery
    Transaction.swift      # Transaction creation and signing
    RPCClient.swift        # JSON-RPC client for Ethereum nodes
    Balance.swift          # Balance representation and conversion
    Logger.swift           # Internal logging system
    swiftETH.swift        # Main entry point

Tests/
  swiftETHTests/
    AccountTests.swift           # Unit tests for accounts
    AddressTests.swift           # Unit tests for addresses
    TransactionTests.swift       # Unit tests for transactions
    RPCClientTests.swift         # Integration tests for RPC
    IntegrationTests.swift       # End-to-end tests
    BalanceTests.swift           # Balance conversion tests
    SignatureTests.swift         # Signature tests

Examples/
  swiftETHExample/      # CLI examples
  swiftETHDemo/         # SwiftUI demo app
```

## Development Guidelines

### 1. Adding New Features

When adding a new feature:
1. **Research oxlib.sh** - Check if oxlib.sh has similar functionality
2. **Design the API** - Create Swift-native API that feels natural
3. **Write tests first** - Start with test cases (TDD approach)
4. **Implement** - Write the minimum code to pass tests
5. **Document** - Add inline documentation and update README
6. **Validate** - Ensure all tests pass and no warnings

### 2. Ethereum Functionality

#### Supported Features (Maintain Compatibility)
- âœ… Account generation (secure random)
- âœ… Private key import/export
- âœ… Public key derivation (secp256k1)
- âœ… Address derivation (Keccak-256)
- âœ… EIP-55 checksumming
- âœ… Message signing (ECDSA)
- âœ… Signature recovery
- âœ… Transaction creation
- âœ… EIP-155 signing (replay protection)
- âœ… RLP encoding
- âœ… JSON-RPC client
- âœ… Balance queries
- âœ… Nonce management
- âœ… Gas estimation
- âœ… Transaction sending
- âœ… Transaction receipt fetching
- âœ… Block number tracking
- âœ… Chain ID detection

#### Planned Features (Roadmap)
- ðŸ”„ Smart contract interaction (ABI encoding/decoding)
- ðŸ”„ EIP-712 typed data signing
- ðŸ”„ HD wallet support (BIP-32, BIP-39, BIP-44)
- ðŸ”„ ENS resolution
- ðŸ”„ ERC-20 token support
- ðŸ”„ ERC-721 NFT support
- ðŸ”„ WebSocket subscriptions
- ðŸ”„ Multi-chain support (Polygon, Arbitrum, etc.)
- ðŸ”„ Hardware wallet integration

### 3. Testing Requirements

#### Every Feature Must Have Tests

**Unit Tests** (Fast, isolated, no network)
```swift
// Test individual components in isolation
func testAccountGeneration() throws {
    let account = try swiftETH.generateAccount()
    XCTAssertEqual(account.privateKey.raw.count, 32)
    XCTAssertEqual(account.address.raw.count, 20)
}
```

**Integration Tests** (Real network calls, slower)
```swift
// Test interaction with real Ethereum network
func testGetBalance() async throws {
    let rpcClient = try RPCClient(urlString: "https://eth.llamarpc.com")
    let balance = try await rpcClient.getBalance(address: "0x...")
    XCTAssertGreaterThanOrEqual(balance.toEther(), 0)
}
```

**Test Coverage Goals**
- Minimum 80% code coverage
- 100% coverage for cryptographic functions
- All public APIs must have tests
- Error cases must be tested
- Edge cases must be covered

**Test Naming Convention**
- `test[Feature][Scenario]` - e.g., `testAccountGenerationWithEntropy`
- Use descriptive names that explain what is being tested
- Group related tests in test suites

### 4. Error Handling

**Define Typed Errors**
```swift
// Good: Specific error types
public enum AccountError: Error, LocalizedError {
    case invalidPrivateKey
    case signingFailed
    case invalidAddress
    
    public var errorDescription: String? {
        switch self {
        case .invalidPrivateKey:
            return "The provided private key is invalid"
        case .signingFailed:
            return "Failed to sign the message"
        case .invalidAddress:
            return "The Ethereum address is invalid"
        }
    }
}

// Bad: Generic errors
throw NSError(domain: "Error", code: -1)
```

**Error Context**
- Always provide context in error messages
- Log errors with Logger for debugging
- Include relevant values (sanitized) in error descriptions

### 5. Documentation Standards

**Public APIs Must Be Documented**
```swift
/// Generates a new Ethereum account with a cryptographically secure random private key.
///
/// This function uses `SecRandomCopyBytes` to generate a 32-byte random value
/// for the private key, ensuring cryptographic security.
///
/// - Returns: A new `Account` instance with generated keys and derived address
/// - Throws: `AccountError.generationFailed` if random number generation fails
///
/// Example:
/// ```swift
/// let account = try swiftETH.generateAccount()
/// print("Address: \(account.address.toChecksummed())")
/// ```
public static func generateAccount() throws -> Account {
    // Implementation
}
```

**Documentation Requirements**
- Every public function/struct/class must have documentation
- Include description, parameters, return values, and throws
- Provide usage examples in doc comments
- Keep README.md up to date with new features
- Update TESTING.md when adding new tests

### 6. Cryptography Guidelines

**Security is Paramount**
- Use established libraries (secp256k1.swift, CryptoSwift)
- Never implement custom cryptography
- Always use cryptographically secure random number generation
- Validate all inputs before cryptographic operations
- Clear sensitive data from memory when no longer needed

**Testing Crypto Functions**
- Use known test vectors from Ethereum specifications
- Validate against other implementations
- Test edge cases (zero values, maximum values)
- Ensure deterministic behavior for same inputs

### 7. RPC Client Guidelines

**Ethereum JSON-RPC Support**
- Follow JSON-RPC 2.0 specification
- Support standard Ethereum RPC methods
- Handle errors gracefully (network, node errors)
- Provide clear error messages for common failures
- Support multiple RPC providers (Infura, Alchemy, etc.)

**RPC Method Naming**
- Method names should match Ethereum RPC spec (e.g., `eth_getBalance`)
- Provide Swift-friendly wrappers (e.g., `getBalance()`)

**Example RPC Implementation**
```swift
// Low-level: Direct RPC method
public func call<T: Decodable>(method: String, params: [Any]) async throws -> T

// High-level: Type-safe wrapper
public func getBalance(address: Address) async throws -> Balance {
    let hex: String = try await call(method: "eth_getBalance", params: [address.toHex(), "latest"])
    return Balance(hex: hex)
}
```

### 8. Performance Considerations

- Minimize allocations in hot paths
- Use `@inlinable` for performance-critical functions
- Cache derived values when appropriate
- Avoid unnecessary copying of large data structures
- Profile crypto operations for performance bottlenecks

### 9. Code Style

**Swift Formatting**
```swift
// Use 4 spaces for indentation
// Opening braces on same line
// One blank line between functions
// Group related functionality

public struct Account {
    public let privateKey: PrivateKey
    public let publicKey: PublicKey
    public let address: Address
    
    public init(privateKey: PrivateKey) throws {
        self.privateKey = privateKey
        self.publicKey = try PublicKey(from: privateKey)
        self.address = Address(from: publicKey)
    }
    
    public func sign(message: String) throws -> Signature {
        // Implementation
    }
}
```

**Naming Conventions**
- Use descriptive names (prefer clarity over brevity)
- Boolean variables: `isValid`, `hasBalance`, `canSend`
- Async functions: no special prefix (async/await handles it)
- Factory methods: `make...`, `create...`, or static initializers

**Comments**
- Treat comments as tech debt - only add when necessary
- Prefer self-documenting code over comments
- Use comments to explain "why" not "what"
- Document complex algorithms or non-obvious behavior
- Remove commented-out code before committing

### 10. Dependencies

**Current Dependencies**
- `secp256k1.swift` - Elliptic curve cryptography (required)
- `CryptoSwift` - Keccak-256 hashing (required)

**Adding New Dependencies**
- Minimize external dependencies
- Only add well-maintained, popular libraries
- Prefer Swift-native solutions
- Document security implications
- Pin versions in Package.swift

### 11. Versioning and Releases

**Semantic Versioning**
- MAJOR: Breaking API changes
- MINOR: New features (backward compatible)
- PATCH: Bug fixes (backward compatible)

**Before Release**
- All tests must pass
- Update CHANGELOG.md
- Update version in Package.swift
- Create git tag
- Update README if needed

### 12. Git Commit Guidelines

**Commit Messages**
```
<type>: <subject>

<body>

<footer>
```

**Types**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `test`: Adding/updating tests
- `refactor`: Code refactoring
- `perf`: Performance improvements
- `chore`: Build process or auxiliary tool changes

**Examples**
```
feat: add nonce management to Account class

Added getNonce() method to Account that fetches the transaction
count from an RPC client. Updated UI to display nonce alongside
balance.

Closes #123

test: add comprehensive RPC client integration tests

Added 10 new integration tests for RPCClient covering:
- Balance queries
- Nonce fetching  
- Gas price estimation
- Transaction receipts
- Chain ID detection

All tests pass against Ethereum mainnet.
```

**Signing Commits**
- Always sign commits with GPG or SSH key
- Configure git to require signatures
- User requested: "Always Sign the commit or ask me to do it."

### 13. UI/UX Guidelines (for Demo Apps)

**SwiftUI Best Practices**
- Use native SwiftUI components
- Follow macOS/iOS Human Interface Guidelines
- Provide clear visual feedback for actions
- Handle loading states gracefully
- Display errors clearly to users
- Make sensitive data (private keys) clearly marked

**Demo Application Requirements**
- Should demonstrate all major features
- Include both simple and advanced examples
- Provide copy-to-clipboard functionality
- Show transaction status and results
- Include settings for RPC configuration

### 14. Logging and Debugging

**Logger Usage**
```swift
// Info level for normal operations
Logger.shared.log("Account created: \(address)")

// Error level for failures
Logger.shared.log("Failed to sign transaction", level: .error)

// Include context in logs
Logger.shared.log("RPC Call: \(method) with params: \(params)")
```

**Debug Builds**
- Enable verbose logging
- Include request/response details
- Log timing information for performance analysis

**Production Builds**
- Minimize logging
- Never log sensitive data (private keys, passwords)
- Log errors for debugging user issues

## AI Assistant Instructions

When helping with this project:

1. **Always check oxlib.sh** for API design inspiration before implementing new features
2. **Write tests first** - Follow TDD approach
3. **Consider Swift patterns** - Don't blindly copy TypeScript/JavaScript patterns
4. **Validate cryptography** - Double-check all crypto implementations
5. **Run tests** - Always run `swift test` before completing a task
6. **Update documentation** - Keep README, TESTING.md, and inline docs current
7. **Check for warnings** - Ensure `swift build` produces no warnings
8. **Security first** - Never compromise on security for convenience
9. **Ask before major changes** - Discuss architectural changes with the user
10. **Sign commits** - Remind user to sign commits or ask them to do it

## Common Tasks

### Adding a New RPC Method
1. Check Ethereum JSON-RPC specification
2. Add method to `RPCClient.swift`
3. Create type-safe wrapper function
4. Add unit test in `RPCClientTests.swift`
5. Add integration test if needed
6. Update README with example
7. Run full test suite

### Adding Transaction Support
1. Define transaction type/structure
2. Implement RLP encoding
3. Add signing logic
4. Create tests with known test vectors
5. Add integration test with real network
6. Document usage in README

### Performance Optimization
1. Profile with Instruments
2. Identify bottlenecks
3. Optimize hot paths
4. Add performance tests
5. Verify no regression in functionality
6. Document performance characteristics

## Reference Resources

- **oxlib.sh**: https://oxlib.sh/ (Primary architectural inspiration)
- **Ethereum JSON-RPC**: https://ethereum.org/en/developers/docs/apis/json-rpc/
- **EIPs**: https://eips.ethereum.org/
- **Swift API Design Guidelines**: https://www.swift.org/documentation/api-design-guidelines/
- **secp256k1**: https://github.com/bitcoin-core/secp256k1
- **CryptoSwift**: https://github.com/krzyzanowskim/CryptoSwift

## Quick Reference

```bash
# Build project
swift build

# Run all tests
swift test

# Run specific test
swift test --filter AccountTests

# Run demo app
swift run swiftETHDemo

# Format code (if using swift-format)
swift-format format -i -r Sources/ Tests/

# Check for warnings
swift build 2>&1 | grep warning
```

## Remember

- **Security is non-negotiable** - Always prioritize security over convenience
- **Tests are documentation** - Write clear, descriptive tests
- **API design matters** - Think about developer experience
- **Performance matters** - Profile before optimizing
- **Documentation matters** - Keep docs current and accurate
- **oxlib.sh is the guide** - Follow its design philosophy and API patterns
